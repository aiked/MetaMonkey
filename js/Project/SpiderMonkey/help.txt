JSObject *propertiesObj;
if( !getObjPropertyAndConvertToObj(val, "properties", &propertiesObj) )
	return JS_FALSE;

JSString *kindStr;
if( !getObjPropertyAndConvertToString(propObj, "kind", &kindStr) )
	return JS_FALSE;

JSString *kindStr;
if( !unparse_expr(keyObj, &initKeyStr, indent, 18, false) )
	return JS_FALSE;

JSString *functionStr;
if( !functionDeclaration(kindStr, &functionStr, keyVal, valueObj, indent ) )
	return JS_FALSE;

jsval idVal;
if (!JS_GetProperty(cx, val, "id", &idVal)){
	JS_ReportError(cx, "object has not property (expression)");
	return JS_FALSE;
}

JSString *declStr;
if( !declarators( declObj, &declStr, indent, false) )
	return JS_FALSE;

JSString *ifSubStmtStr;
if(!substmt(consequentObj, &ifSubStmtStr, indent, gotElse))
	return JS_FALSE;

jsval labelVal;
if (!JS_GetProperty(cx, val, "label", &labelVal))
	return JS_FALSE;

if( labelVal.isObject() ){
	JSObject *labelObj;
	if( !JS_ValueToObject(cx, labelVal, &labelObj) )
		return JS_FALSE;

*child = joinStringVector(&children, NULL, NULL, NULL);

if( !wrapExpr(child, cprec, 3) )
		return JS_FALSE;

JS_NewStringCopyZ(cx,"init");

*child = joinString(3, nameStr, srcStr(JSSRCNAME_COLONSPACE), bodyStr);

Vector<JSString*> children(cx);

--------------------------------------------------------------------------------------
var cases = n.cases;
var s = indent + "switch (" + expr(n.discriminant, indent, 0, false) + ") {\n";
var deeper = indent + indentChar;

for (var j = 0; j < n.cases.length; j++) {
    var scase = cases[j];
    s += indent;
    s += (scase.test ? "case " + expr(scase.test, indent, 0, false) : "default");
    s += ":\n";
    var stmts = scase.consequent;
    for (var i = 0; i < stmts.length; i++)
        s += stmt(stmts[i], deeper);
}
return s + indent + "}\n";


